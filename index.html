<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Utakata Tanka Carousel</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        margin: 0;
        font-family: "Noto Serif JP", "Yu Mincho", "Hiragino Mincho ProN", "Times New Roman", serif;
        background: radial-gradient(circle at top, #f7efe4 0%, #eaf2f0 60%, #f2e9f0 100%);
        color: #2a2a2a;
      }
      .wrap {
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }
      header {
        padding: 16px 20px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        background: rgba(255, 255, 255, 0.82);
        backdrop-filter: blur(6px);
      }
      header h1 {
        margin: 0 0 6px 0;
        font-size: 18px;
        color: white;
        letter-spacing: 0.06em;
        background-color: #0095d9;
        
      }
      header .meta {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        font-size: 13px;
        opacity: 0.85;
      }
      .meta .control {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 2px 10px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.06);
      }
      .meta select {
        border: 0;
        background: transparent;
        font-family: inherit;
        font-size: 12px;
      }
      .meta input[type="range"] {
        accent-color: #2f5f4f;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 10px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.06);
      }
      .frame {
        padding: 28px 20px 16px;
      }
      .card {
        max-width: 600px;
        margin: 0 auto;
        padding: 24px 24px 18px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 14px 40px rgba(0, 0, 0, 0.08);
      }
      .card h2 {
        margin: 0 0 12px 0;
        font-size: 16px;
      }
      .tanka-block {
        min-height: 600px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(0, 0, 0, 0.06);
        cursor: pointer;
        overflow: auto;
        opacity: 1;
        transition: opacity 500ms ease;
      }
      #tanka-block {
        border-radius: 16px !important;
        overflow: hidden;
      }
      .tanka-block.is-fading {
        opacity: 0;
      }
      @media (prefers-reduced-motion: reduce) {
        .tanka-block {
          transition: none;
        }
      }
      .tanka-block [class*="border-l-"] {
        border-left-width: 0 !important;
        padding-left: 0 !important;
      }
      .tanka-block :where(a) {
        color: inherit;
        text-decoration: none;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 14px;
      }
      button {
        border: 0;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 11px;
        cursor: pointer;
        background: #2f5f4f;
        color: #fff;
      }
      .controls button {
        border-radius: 999px !important;
        padding: 4px 10px !important;
        font-size: 11px !important;
        line-height: 1.2;
      }
      button.secondary {
        background: #1f3f57;
      }
      footer {
        padding: 10px 20px 18px;
        font-size: 12px;
        opacity: 0.72;
      }
      .status {
        font-size: 12px;
        opacity: 0.75;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <h1>Utakata Tanka Carousel</h1>
        <div class="meta">
          <div class="control">
            <label for="interval">Interval:</label>
            <input id="interval" type="range" min="5" max="60" step="1" value="30" />
            <span id="interval-value">10s</span>
          </div>
          <div class="control">
            <label for="source">Source:</label>
            <select id="source">
              <option value="popular">人気の歌</option>
              <option value="new" selected>新しい歌</option>
            </select>
          </div>
          <div class="pill">Loaded: <span id="count">0</span></div>
          <div class="pill">Next in: <span id="timer">10</span>s</div>
        </div>
      </header>
      <div class="frame">
        <div class="card">
          <div id="tanka-block" class="tanka-block">Loading…</div>
          <div class="controls">
            <button id="next">次を表示</button>
            <button id="reload" class="secondary">リスト再読み込み</button>
          </div>
          <div id="status" class="status"></div>
        </div>
      </div>
      <footer>
        指定した時間で短歌を切り替えて表示します。
      </footer>
    </div>

    <script>
      const API_URL = "/api/tanka";
      const API_PAGE_URL = "/api/tanka-page";
      const API_ASSET_URL = "/api/asset";
      const BASE_URL = "https://utakatanka.jp";
      const DEFAULT_INTERVAL_MS = 30000;
      const FADE_MS = 500;

      const countEl = document.getElementById("count");
      const timerEl = document.getElementById("timer");
      const statusEl = document.getElementById("status");
      const tankaBlock = document.getElementById("tanka-block");
      const intervalInput = document.getElementById("interval");
      const intervalValue = document.getElementById("interval-value");
      const sourceSelect = document.getElementById("source");
      const nextBtn = document.getElementById("next");
      const reloadBtn = document.getElementById("reload");

      let tankaList = [];
      let rotateId = null;
      let countdownId = null;
      let intervalMs = DEFAULT_INTERVAL_MS;
      let remaining = Math.floor(intervalMs / 1000);
      let requestId = 0;
      let currentItem = null;
      let currentSource = "popular";
      const injectedStylesheets = new Set();
      const injectedStyleBlocks = new Set();
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      function updateCountdown() {
        timerEl.textContent = String(remaining);
      }

      function parseTanka(html) {
        const doc = new DOMParser().parseFromString(html, "text/html");
        const links = [...doc.querySelectorAll("a.tanka-link")];
        return links
          .map((link) => {
            const href = link.getAttribute("href");
            const text = link.textContent ? link.textContent.trim() : "";
            if (!href || !text) {
              return null;
            }
            return {
              href: new URL(href, BASE_URL).toString(),
              text,
            };
          })
          .filter(Boolean);
      }

      function applyPageStyles(doc) {
        const stylesheets = [...doc.querySelectorAll('link[rel="stylesheet"]')];
        stylesheets.forEach((link) => {
          const href = link.getAttribute("href");
          if (!href) {
            return;
          }
          const absoluteUrl = new URL(href, BASE_URL).toString();
          if (injectedStylesheets.has(absoluteUrl)) {
            return;
          }
          injectedStylesheets.add(absoluteUrl);
          const styleLink = document.createElement("link");
          styleLink.rel = "stylesheet";
          styleLink.href = `${API_ASSET_URL}?url=${encodeURIComponent(absoluteUrl)}`;
          document.head.appendChild(styleLink);
        });

        const styleBlocks = [...doc.querySelectorAll("style")];
        styleBlocks.forEach((styleTag) => {
          const content = styleTag.textContent ? styleTag.textContent.trim() : "";
          if (!content || injectedStyleBlocks.has(content)) {
            return;
          }
          injectedStyleBlocks.add(content);
          const newStyle = document.createElement("style");
          newStyle.textContent = content;
          document.head.appendChild(newStyle);
        });
      }

      function extractBlock(doc) {
        const target = doc.querySelector("div.mt-4.vertical.serif.mx-auto.text-nowrap");
        if (!target) {
          return null;
        }
        let node = target;
        let best = null;
        for (let i = 0; i < 6 && node; i += 1) {
          if (node.querySelector && node.querySelector('a[href^="/kajin/"]')) {
            best = node;
          }
          node = node.parentElement;
        }
        return best || target;
      }

      function normalizeUrls(container) {
        const anchors = [...container.querySelectorAll("a[href]")];
        anchors.forEach((anchor) => {
          const href = anchor.getAttribute("href");
          if (!href) {
            return;
          }
          const absoluteUrl = new URL(href, BASE_URL).toString();
          anchor.setAttribute("href", absoluteUrl);
          anchor.setAttribute("target", "_blank");
          anchor.setAttribute("rel", "noopener noreferrer");
        });

        const images = [...container.querySelectorAll("img[src]")];
        images.forEach((img) => {
          const src = img.getAttribute("src");
          if (!src) {
            return;
          }
          const absoluteUrl = new URL(src, BASE_URL).toString();
          const proxiedUrl = `${API_ASSET_URL}?url=${encodeURIComponent(absoluteUrl)}`;
          img.setAttribute("src", proxiedUrl);
        });
      }

      function pruneSiteHeader(container) {
        const headerLinks = ["/tanka", "/users/sign_up", "/users/sign_in", "/about"];
        const anchors = [...container.querySelectorAll("a[href]")];
        const hit = anchors.find((anchor) => {
          const href = anchor.getAttribute("href") || "";
          return headerLinks.some((value) => href.includes(value));
        });
        if (hit) {
          const navCandidate = hit.closest("nav") || hit.closest("ul") || hit.closest("header") || hit.parentElement;
          if (navCandidate && navCandidate !== container) {
            navCandidate.remove();
          }
        }
      }

      function wait(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function applyWithFade(updateFn) {
        if (prefersReducedMotion) {
          updateFn();
          return;
        }
        tankaBlock.classList.add("is-fading");
        await wait(FADE_MS);
        updateFn();
        requestAnimationFrame(() => {
          tankaBlock.classList.remove("is-fading");
        });
      }

      async function loadDetail(item) {
        const currentRequest = (requestId += 1);
        currentItem = item;
        statusEl.textContent = "Loading tanka...";
        try {
          const path = new URL(item.href).pathname;
          const response = await fetch(`${API_PAGE_URL}?path=${encodeURIComponent(path)}`, {
            cache: "no-store",
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const html = await response.text();
          const doc = new DOMParser().parseFromString(html, "text/html");
          if (currentRequest !== requestId) {
            return;
          }
          applyPageStyles(doc);
          const block = extractBlock(doc);
          if (block) {
            await applyWithFade(() => {
              tankaBlock.innerHTML = block.outerHTML;
              normalizeUrls(tankaBlock);
              pruneSiteHeader(tankaBlock);
              statusEl.textContent = "";
            });
          } else {
            await applyWithFade(() => {
              tankaBlock.textContent = item.text;
              statusEl.textContent = "Fallback to link text (block not found).";
            });
          }
        } catch (error) {
          if (currentRequest !== requestId) {
            return;
          }
          await applyWithFade(() => {
            tankaBlock.textContent = item.text;
            statusEl.textContent = "Failed to load tanka content. Showing link text.";
          });
          console.error(error);
        }
      }

      function showRandom() {
        if (!tankaList.length) {
          return;
        }
        const index = Math.floor(Math.random() * tankaList.length);
        const item = tankaList[index];
        loadDetail(item);
      }

      function resetTimers() {
        if (rotateId) {
          clearInterval(rotateId);
        }
        if (countdownId) {
          clearInterval(countdownId);
        }
        remaining = Math.floor(intervalMs / 1000);
        updateCountdown();

        countdownId = setInterval(() => {
          remaining = Math.max(remaining - 1, 0);
          updateCountdown();
        }, 1000);

        rotateId = setInterval(() => {
          showRandom();
          remaining = Math.floor(intervalMs / 1000);
          updateCountdown();
        }, intervalMs);
      }

      async function loadList() {
        statusEl.textContent = "Loading list...";
        try {
          const response = await fetch(`${API_URL}?source=${encodeURIComponent(currentSource)}`, {
            cache: "no-store",
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const html = await response.text();
          tankaList = parseTanka(html);
          countEl.textContent = String(tankaList.length);
          if (!tankaList.length) {
            tankaBlock.textContent = "No tanka links found.";
            statusEl.textContent = "The page structure may have changed.";
            return;
          }
          showRandom();
          resetTimers();
        } catch (error) {
          statusEl.textContent = "Failed to load list. See console.";
          tankaBlock.textContent = "Unable to load.";
          console.error(error);
        }
      }

      nextBtn.addEventListener("click", () => {
        if (!tankaList.length) {
          return;
        }
        showRandom();
        remaining = Math.floor(intervalMs / 1000);
        updateCountdown();
      });

      reloadBtn.addEventListener("click", loadList);

      sourceSelect.addEventListener("change", () => {
        currentSource = sourceSelect.value;
        loadList();
      });

      intervalInput.addEventListener("input", () => {
        const seconds = Number(intervalInput.value);
        intervalMs = Math.max(1000, seconds * 1000);
        intervalValue.textContent = `${seconds}s`;
        resetTimers();
      });

      tankaBlock.addEventListener("click", (event) => {
        if (event.target && event.target.closest("a")) {
          return;
        }
        if (currentItem) {
          window.location.href = currentItem.href;
        }
      });

      intervalValue.textContent = `${intervalInput.value}s`;
      intervalMs = Number(intervalInput.value) * 1000;
      currentSource = sourceSelect.value;
      loadList();
    </script>
  </body>
</html>
